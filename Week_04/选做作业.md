1、列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点。 

锁机制类 Locks : Lock, Condition, ReadWriteLock，synchronize

synchronize:锁力度较粗，不灵活，只能通过锁代码块。可以用ReentrantLock更加灵活。ReadWriteLock可以做读写锁分离。Condition可以作为简单的协作机制。

原子操作类Atomic : AtomicInteger

AtomicInteger类可以用于计数，源码使用的CAS和Volatile配合做原子类操作

线程池相关类Executer : Future, Callable, Executor

Executors可以直接生成4种不同的线程池应对不同场景。Future, Callable可以返回线程执行结果。

信号量三组工具类Tools : CountDownLatch, CyclicBarrier, Semaphore

Semaphore类似令牌桶可以控制流量，CyclicBarrier(循环屏障), 可以让一组线程等待满足某个条件后同时执行。CountDownLatch(闭锁)可以看作一个只能做减法的计数器，可以让一个或多个线程等待执行。

并发集合类Collections : CopyOnWriteArrayList, ConcurrentMap

HashMap在并发情况下可能会发生死循环，所以要使用ConcurrentMap。CopyOnWriteArrayList通过clone对象减少锁的时间，使用空间换时间。



2、请思考:什么是并发?什么是高并发?实现高并发高可用系统需要考虑哪些 因素，对于这些你是怎么理解的?

并发：指多个线程在共同完成一件事情，单位时间内多个线程同时运行。

并行：同一时刻多个线程同时运行。

高并发：高并发（High Concurrency）是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况

高并发衡量指标：TPS，QPS。

解决高并发一般从以下层面考虑：数据库，缓存，微服务，消息队列，负载均衡等。一般影响并发量的问题不在计算，而在IO，所以优化好IO可以极大的提高并发量

优化的地方一般有：

代码优化：多线程，算法优化，同步改异步，减少锁力度，最终一致性

数据库优化：水平拆分，垂直拆分，读写分离，索引优化，冷热数据分离

业务优化：如12306分时段抢票。



 

3、请思考:还有哪些跟并发类似/有关的场景和问题，有哪些可以借鉴的解决 办法。 

秒杀系统。

秒杀系统是一个很好的搞并发的场景。会出现很多问题

缓存：比如缓存击穿，缓存雪崩。

兜底方案：

减少库存：数据库行锁，事务隔离级别。

削峰填谷：使用消息队列削峰。

前端：减少无用请求(一分钟内最多请求5次之类)

CDN：动静分离