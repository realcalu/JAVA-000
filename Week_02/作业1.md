![Image text](https://raw.githubusercontent.com/realcalu/JAVA-000/main/Week_02/image/image-20201028223151641.png)

### 现象
1. 从上图可以得知，内存分配为512m的情况下SerialGC的效率还可以，但内存比较小对于parallerGC并不友好，minor gc的次数会比较多，cms gc的full gc次数会比较少，但gc时间并没有比serial gc时间短很多，而G1的gc次数虽然很多，但gc总时间在4个gc中是最短的。但我试过在内存为256m的情况下，G1 gc会oom但其他三个并不会。
2. 内存分配为1g的情况下，G1 gc仍然是最好的，虽然gc的次数为第二高，但gc的总时长却是最短的。parallel GC 此时比分配512m内存的时候好很多，gc的时间缩短，而且gc次数也减少了，CMS GC则是仅次于G1 GC的，其gc总时间短，而且每次gc的时间都不会很长。
3. 内存分配为2g的情况下，4个GC 都没有full gc的情况，内存分配充足。此时的G1的GC次数虽然比另外三个要多，但其每次gc的时间非常短，所以gc的总时间也短。CMS和Serial的gc次数一样，但CMS的GC总时间比Serial 要短。而parallel的gc次数虽然有点高，但gc总时长和CMS一样。
4. 内存分配为4g的情况下，SeralGC话和Paraller的gc次数最少，但Parallel的gc时间比serial要短很多，不管是gc总时长还是每次gc的时间都比parallel要短很多。而cms虽然gc次数较多，gc总时长比较高，但每次gc的时间都很短。g1则每次gc的时间比较长却gc次数较多。



### 不同GC的特性和应用场景：

#### Serial 

1. 特性：
这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Stop The World

1. 应用场景：
Serial收集器是虚拟机运行在Client模式下的**默认**新生代收集器；也可使用-XX:+UseSerialGC指定。

1. 优势：
简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。


#### CMS

1. 优点：
CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。

1. 缺点：
- CMS收集器对CPU资源非常敏感：其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。

- CMS收集器无法处理浮动垃圾：CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
- CMS收集器会产生大量空间碎片：CMS是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。



#### G1

G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。

1. 并行与并发
G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

1. 分代收集
与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC内存，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

1. 空间整合
与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

1. 可预测的停顿
这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。



#### Parallel

1. 特性：
Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。server模式下的默认GC方式，也可用-XX:+UseParallelGC强制指定。Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。

1. 应用场景：
停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。server模式下的**默认**GC方式，也可用-XX:+UseParallelGC=强制指定；可以在选项后加等号来制定并行的线程数。





我项目中常用的GC是CMS+ParNew

CMS 处理过程有七个步骤：

- 初始标记 ,会导致stw;
- 并发标记 ，与用户线程同时运行；
- 预清理 ，与用户线程同时运行；
- 可被终止的预清理 ，与用户线程同时运行；
- 重新标记 ，会导致swt；
- 并发清除 ，与用户线程同时运行；



      CMS虽然经过这么些年的考验，已经是一个值得信赖的GC回收器了，但是，其实也是有一些他的不足的，

1.  **垃圾碎片的问题** ，我们都知道CMS是使用的是 **标记-清除** 算法的，所以不可避免的就是会出现垃圾碎片的问题。
2.  一般CMS的GC耗时80%都在remark阶段，remark阶段停顿时间会很长 ，在CMS的这四个主要的阶段中，最费时间的就是重新标记阶段。
3.  **concurrent mode failure** ，这个异常发生在cms正在回收的时候。执行CMS GC的过程中，同时业务线程也在运行，当年轻带空间满了，执行young gc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时CMS还没有机会回收老年代产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。
4.  **promotion failed** ，这个问题是指，在进行Minor GC时，Survivor空间不足，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年代有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大,找不到一段连续区域存放这个对象导致的。
5. **垃圾碎片的问题** ：针对这个问题，这时候我们需要用到这个参数： -XX:CMSFullGCsBeforeCompaction=n 意思是说在上一次CMS并发GC执行过后，到底还要再执行多少次 full GC 才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。
6. **concurrent mode failure**  解决这个问题只需要设置两个参数即可-XX:+UseCMSInitiatingOccupancyOnly，-XX:CMSInitiatingOccupancyFraction=60：是指设定CMS在对内存占用率达到60%的时候开始GC。为什么设置这两个参数呢？由于在垃圾收集阶段用户线程还需要运行，那也就还需要 **预留有足够的内存空间给用户线程使用** ，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集。当然也不能设置过高，比如90%，这时候虽然GC次数少，但是，却会导致用于用户线程空间小，效率不高，太低10%。
7. **remark阶段停顿时间会很长的问题** ：解决这个问题就是加入 -XX:+CMSScavengeBeforeRemark 。在执行remark操作之前先做一次 Young GC ，目的在于减少年轻代对老年代的无效引用，降低remark时的开销。





