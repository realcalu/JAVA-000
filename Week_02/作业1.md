![image-20201028223151641](/Users/apple/Library/Application Support/typora-user-images/image-20201028223151641.png)

1. ### 现象
   1. 从上图可以得知，堆分配为512m的情况下SerialGC的效率还可以，但内存比较小对于parallerGC并不友好，minor gc的次数会比较多，cms gc的full gc次数会比较少，但gc时间并没有比serial gc时间短很多，而G1的gc次数虽然很多，但gc总时间在4个gc中是最短的。但我试过在内存为256m的情况下，G1 gc会oom但其他三个并不会。
   2. 堆分配为1g的情况下，G1 gc仍然是最好的，虽然gc的次数为第二高，但gc的总时长却是最短的。parallel GC 此时比分配512m堆的时候好很多，gc的时间缩短，而且gc次数也减少了，CMS GC则是仅次于G1 GC的，其gc总时间短，而且每次gc的时间都不会很长。
   3. 堆分配为2g的情况下，4个GC 都没有full gc的情况，内存分配充足。此时的G1的GC次数虽然比另外三个要多，但其每次gc的时间非常短，所以gc的总时间也短。CMS和Serial的gc次数一样，但CMS的GC总时间比Serial 要短。而parallel的gc次数虽然有点高，但gc总时长和CMS一样。
   4. 堆分配为4g的情况下，SeralGC话和Paraller的gc次数最少，但Parallel的gc时间比serial要短很多，不管是gc总时长还是每次gc的时间都比parallel要短很多。而cms虽然gc次数较多，gc总时长比较高，但每次gc的时间都很短。g1则每次gc的时间比较长却gc次数较多。

   

   ### 不同GC的特性和应用场景：

   #### Serial 

   1. 特性：
   这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Stop The World

   1. 应用场景：
   Serial收集器是虚拟机运行在Client模式下的**默认**新生代收集器；也可使用-XX:+UseSerialGC指定。

   1. 优势：
   简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。


   #### CMS

   1. 优点：
   CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。

   1. 缺点：
   - CMS收集器对CPU资源非常敏感：其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。

   - CMS收集器无法处理浮动垃圾：CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
   - CMS收集器会产生大量空间碎片：CMS是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

   

   #### G1

   G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。

   1. 并行与并发
   G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

   1. 分代收集
   与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

   1. 空间整合
   与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

   1. 可预测的停顿
   这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

   

   #### Parallel

   1. 特性：
   Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。server模式下的默认GC方式，也可用-XX:+UseParallelGC强制指定。Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。

   1. 应用场景：
   停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。server模式下的**默认**GC方式，也可用-XX:+UseParallelGC=强制指定；可以在选项后加等号来制定并行的线程数。





